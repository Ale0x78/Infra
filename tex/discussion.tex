\section{Discussion}
\label{sec:discussion}

We argue that the complexity of phishing page client-side code aids in analyzing the massive volume of phishing pages in the wild, aided by the proliferation of phishing kits. In this section, we discuss the interaction between what makes kits identifiable, why use browser APIs, and what the clusters represent.

\subsection{What makes a kit identifiable?}
The more sophisticated the phishing kit becomes, the easier it is to spot by just the browser APIs it uses, as everything from how it chooses to evade researchers to how the UI libraries they use build the DOM, can make it stand out. In plain JavaScript, without browser APIs, a page can not reach a C2 server, gather browser fingerprints, dynamically generate or cloak page contents, request browser pop-ups, or even respond to a button click. In the case of the pages clustered in Figure~\ref{fig:ms_defender}, the APIs \textit{Keyboard.lock}, \textit{HTMLDocument.onkeydown} for keyboard locking, \textit{Window.atob} for obfuscation, and a handful of fingerprint APIs and DOM APIs for dynamic content generation, set these pages apart from the other clusters. 

This, however, does not indicate that browser API usage alone is a good indicator of maliciousness. All of the techniques described in Section~\ref{sec:methods} are common throughout the web. Phishing pages are singular in their purpose, and their choice to engage in these techniques sets them apart.
\subsection{Why cluster phishing pages?}
\emph{At worst, we overestimate how popular different techniques are across kits}. As shown in the examples in this paper, phishing feeds can be a noisy data source for studying the overall ecosystem. From e-commerce pages to mass-spammed USPS and EZ-parking phishing pages, differentiating between a handful of pages, the methodology in this paper is aimed at researchers and analysts. For research, identifying kits in a dataset of phishing kits helps control for easily obtainable or mass-deployed phishing kits, measuring the prevalence of different techniques across kits, rather than pages. Features extracted from dynamic execution with unsupervised learning for establishing when two pages are similar allow for resilience towards run-of-the-mill obfuscation of the client-side code. 
For analysts, our methodology acts as a quick way to aggregate and share phishing kits-related threat intelligence between pages. Things like server-side cloaking technique, preferred exfiltration method, ties to APTs, and data exfiltrated. While kit-families can vary in which IPs they denylist, and what user-agents they allow, fingerprinting the underlying kit can allow analysts to deduce if a page employs these techniques in the first place. 

