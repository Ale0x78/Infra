\section{Discussion}
\label{sec:discussion}
\input{figures/brand_vs_phishing.tex}
\subsection{Why clusters?}
As shown in the examples in this paper, phishing feeds can be a noisy data source for studying the overall ecosystem. From e-commerce pages to mass-spammed USPS and EZ-parking phishing pages, differentiating between a handful of pages of varying sizes becomes crucial for efficiency. This paper demonstrates that browser API usage can closely proxy the phishing kit (providing commonality for the page's origin) at best and group via standard client-side techniques at worst.

Furthermore, cluster membership with a page of a known kit and a high number of common cluster APIs can let you infer server-side behavior about the page. As established by Oest~\etal{}, phishing kits thrive on including up-to-date IP blocklists. However, this blocklist is not always included in the client-side code. Looking at the pages as is, without any forced execution, will allow easier triaging of failed detections and crawls as it will cluster them all together.

\subsection{What makes a kit identifiable?}
Sets of browser APIs used are not the most granular method to describe pages; however the more sophisticated the phishing kit becomes, the easier it is to spot by just the browser APIs it uses, as everything from how it chooses to evade researchers to how the UI libraries they use build the DOM, can make it stand out. In plain JavaScript, without browser APIs, a page can not reach out to a C2 server, gather browser fingerprints, dynamically generate or cloak page contents, request browser pop-ups, or even respond to a button click. In the case of the pages clustered in Figure~\ref{fig:ms_defender}, the APIs \textit{Keyboard.lock}, \textit{HTMLDocument.onkeydown} for keyboard locking, \textit{Window.atob} for obfuscation, and a handful of fingerprint APIs and DOM APIs for dynamic content generation, set these pages apart from the other clusters. 

\paperFinding{Phishing pages vary wildly from the brand that they are mimicking}
We collect browser API traces from Facebook, USPS, Meta, Microsoft, and IRS login pages and compare them to their phishing counterparts. The average similarity of the APIs executed by the phishing page and the original page is 11\%, indicating that browser APIs do not relate to the target page. We found no pages where the original page's API set was a subset of the phishing page's API set, and in 5\% of the cases, the phishing page executed at least half of the APIs from the original page. We report per-brand findings in Table~\ref{tab:phishing-metrics} and note that the least similar brand was USPS, which could be the result of USPS phishing pages being multi-stage pages requiring user interaction and targeting credit card information~\cite{centerUSPSPhishingScam}.

This, however, does not indicate that browser API usage alone is a good indicator of maliciousness. All of the techniques described in Section~\ref{sec:methods} are common throughout the web. Phishing pages are singular in their purpose, and their choice to engage in these techniques sets them apart from one another.

\subsection{Dynamic analysis combats evasions}
While dynamic analysis suffers from drawbacks we will discuss in Section~\ref{sec:limitations}, it allows us to sidestep a subset of sophisticated obfuscation techniques. Even something as nuanced as an AES-encrypted script will show up in VisisbleV8 as long as the behavior is triggered and calls out to browser APIs. While not incorporated by our work, prior work has shown forced execution ~\cite{fv8-sec24,zhangCrawlPhishLargescaleAnalysis2021} to ensure that dynamic analysis effectively extracts all behaviors.