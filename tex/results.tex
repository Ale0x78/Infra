
\section{Results (3-4 pages)} 
\label{sec:results}

\input{figures/clusters_per_month.tex}

In this section, we will evaluate our clustering approach against the ground truth, inspect the distribution of ground truth pages in the final clusters, and report temporal patterns and the commonality of phishing behaviors across those clusters. In total, we crawled for \daysCrawled{} days collecting browser traces from \totalPageWithJavascript{} pages, out of which only \totalPagesWithJavascriptFP{} qualified for clustering by executing at least 8 APIs. Further more, 99,464 pages were clustered as noise by HDBSCAN or formed a cluster where all the pages had no common APIs.

\subsection{Characteristics of clusters}

\input{figures/intra_kit_sim.tex}

\paperFinding{Pages from different kits employ vastly different APIs} Figure-\ref{fig:intra_kit_sim} shows the distribution of Jecard-based similarity between pages from the same kit versus different kits. We observe that pages from different kits, even ones with similar themes, rarely exceed 60\% similarity,  while most pages with the same kit have around 90-100\% similarity. We leverage this in our clustering by treating $1 - JI(A,B)$ as a distance kernel of HDBSCAN. 
\input{figures/ms_defender.tex}

\paperFinding{Browser API usage unique identify phishing kits apart from eachother} Clustering pages from \totalKitPages{} pages across \totalKits{} kits, yeild \totalKitClusters{} clusters. Evaluating these clusters against the ground truth labels for each page, we find that our clusters have an FMI-based accuracy of \gtFMI{}. The clusters have a V-Score of \gtVS{}, which increases with a higher $\beta$, meaning the clusters tend to combine two kits into one instead of splitting pages from the same kit across multiple clusters. \todowrite{Actually no... homoginocity mean that the kits are being split across multiple clusters}

Pages with ground truth labels for originating kits remain appropriately sorted out in the clustering of the \totalPagesClusterable{} pages, as out of the 3,505 pages clustered within the larger clusters, we maintain an FMI of 0.948 and a V-Score of 0.889, respectively.
Manually inspecting the clusters, we observe that these clusters unique pages across deployment types (AWS, Cloudflare, DigitalOcean, etc.) and languages. For example, Cluster-e325887b comprises 487 pages across 5 unique e2TLDs and contains pages engaging in voice-based phishing attacks (tech support scams) across Japanese, English, and German, varying phone numbers and errors in each, shown in Figure-\ref{fig:ms_defender}. With over 400 APIs in common, it is clear that these pages' usage of keyboard intercepting APIs, Audio APIs, and Network APIs for IP intelligence caused the cluster to be formed.

% Ignoring some types of APIs, reduces the number of pages you can cluster, while not impacting the FMI or V-Score
\paperFinding{DOM APIs and property accesses play an essential role in identifying the underlying kit} With \TotalAPIs{} browser APIs, feature reduction becomes an obvious goal. However, removing DOM-related APIs, or property reads, out of consideration drastically reduces the number of pages we can consider for ground truth evaluation, not increasing our overall accuracy. Evaluated our same methodology described in Section-\ref{sec:methods} with all HTML-DOM, SVG, and CSS APIs removed and observed FMI-based accuracy of 0.93 and V-Score of 0.86. When all property reads were removed (often used in finterprinting\cite{jsufp}), we saw FMI and V-Score of 0.93 and 0.85, respectively. In both cases, we can cluster fewer pages and thus identify fewer kits. 
% Finally, to ensure that the distance metric is sufficient to isolate pages from different kits in most cases, we attempt to cluster all XXX pages from YYY kits, even if we only observed a single page from that kit. Allowing HDBSCAN to form singleton clusters, we see that these pages can still be differentiated from one another with an FMI of XXXX and V-Score of YYYY.
% We will discuss this later in the discussion, but it should be noted that we aggregate pages across different languages and deployment infra



\paperFinding{Majority of clusters map to a single brand} 80\% of clusters contain urls only marked by a single target brand by our threat intel sources\footnote{We did not include clusters in this count that had no brand labeled urls in them}. 534 clusters (15\%) had two brand labels, however the most popular combination of these were "Meta/Facebook", "National Police Agency JAPAN/Facebook", and "Facebook/Instigram", keeping the parent organization of the target the same in majority of the cases. Manual examination of clusters with "National Police Agency JAPAN/Facebook" brand labels revealed shopping pages in Japanese to be marked with that label in correctly from our data feeds. The cluster with the most diverse set of brand labels had 14 unique brand labels, which was a cluster with 12,467 pages with simple sign-in pages that exfiltrated information using client-side registered event listeners to exfiltrate data using client-side javascript. 

\subsection{Temporal patterns of clusters}

\paperFinding{Majority of phishing pages that execute originate from the same 50 clusters}
\totalFromTop{} pages of pages that executed javascript in a first-party context (\totalPagesWithJavascriptFP{}) are sorted into one of the 50 top clusters. The 10 clusters by page count are 20.8\% of the total pages alone. We provide a breakdown of these clusters along with manual labeling of what campaigns they corespond to in Figure-\ref{fig:top_10_clusters}. We note that one of the clusters, we simplly labeled dynamically generated, as this turned out to be a noisy cluster of simple pages that dynamically generate part of their page, without any sophisicated client-side behavior. The E-comerse cluster shown in, Figure-\ref{fig:top_10_clusters} has a significant seasonalality as lags 7, 14, and 21, meaning the appearence of the clusters on the feeds happens every week. However, further investigation showed that majority of seasonal clusters are simular e-comerse phishing clusters, with vastly different dynamic behavior, letting us to conclude that the seasonalality in majority of the clusters is due to regular reporting by threat-intelligence sources to our feeds, and not seasonal deployments of kits.

\paperFinding{72\% of the clusters (144,695), and by extension kits, are only seen for a single month by phishing feeds} 15\% of the clusters (14,555 pages) we observe are only seen for one day, along which were pages deployed on blogpost, brandless bank pages, and phishing page impercenating the goverment of Korea. Meanwhile, 1,282 clusters (11\%) have lifetimes longer then 100 days. 

\paperFinding{Clusters re-emerge after some downtime} Some clusters that have a lifetime greater then 100 days, still only deploy a few pages (less then 1 page every 10 days). We use this as a heuristic to identify 251 clusters 're-emerge' through our observation period. 

\subsection{Phishing Techniques across clusters}

% UI interactivity is a dominant behavior!
\paperFinding{UI interactivity and fingerprinting are a near-universal behavior across clusters}. Multi-stage phishing pages are very well documented in prior work, and we find that the majority of clusters (91\%) register a click event listener using JavaScript. Though this could be as simple as submitting credentials using JavaScript, this highlights the need for researchers to augment their crawlers in the future to extract better and more complete execution traces from websites. As mentioned in Section-\ref{sec:methods}, we split fingerprinting into two categories, basic and advanced. Basic fingerprinting, which follows the list of APIs identified by Zhang\etal in \cite{zhang_crawlphish_2021} was present in 80\% of the clusters (over 300,000 pages), and Advance fingerprinting (measured by at least 5 APIs idenfied by Su\etal in \cite{jsufp}) show up in 70\% of the clusters. Together, 85\% of clusters (9572 clusters, 313,212 pages) exhibit some kind of fingerprinting.
\input{figures/obfuscation_tactics.tex}

\paperFinding{Fingerprint exfiltration, obfuscation, and bot detection are widespread phishing clusters} While fingerprinting is near universal, we find that a smaller fraction of the clusters employ obfuscation, fingerprint exfiltration, and timing for bot detection. We present the breakdown of all these techniques in Table-\ref{tab:obfuscaiton}. We find that 22\% of clusters call out use Performance.now inconjecture with setTimeout, enabling delta time measurement for bot detection. 46\% of pages call at least five advanced fingerprinting APIs, followed by an exfiltration-related API.

31\% of clusters (2,395) employ some form of obfuscation. A full breakdown of different obfuscation forms is in Table-\ref{tab:obfuscaiton} and as we can see eval and Base64 encoding were the most popular way of obfuscaiton. Despite the best recommendations\cite{EvalJavaScriptMDN2025} to web developers, JavaScript's eval function remains a favorite for obfuscation and evasions \cite{fv8-sec24}. Sometimes, a script is executed via `eval()', which evaluates yet another script itself; we measure this phenomenon as a level in \textbf{eval-depth}. We find that 48 clusters have pages that go to eval-depth 3, however, this seems to be a side-effect of embeding the phishing pages (mainly ones targetting facebook) in a blogpost page.


\input{figures/ipinfo.tex}

\paperFinding{Phishing pages make network requests using JavaScript before any user interaction}. While only present in 504 clusters (19,869 pages), we identify 15 unique IP reputation APIs used by phishing pages as soon as the page loads. We present a full breakdown in Table-\ref{tab:ip_rep}. While not the most popular, \textit{api.ipregistry.co} presents an interesting case study, as it enables the identification of educational networks. Manual examination of pages from these clusters reveals snippets similar to Figure-\ref{fig:ip_example}

\input{figures/timeline.tex}
\paperFinding{Pop-UP APIs are on a decline} We see only 104 cluster (1,323 pages) call out to pop-up requesting APIs. Among these, the most popular was Geolocation.getCurrentPosition (55 clusters). This API, while requiring a pop-up to interact with, can also play a crutial role in cloaking, as the results are not masked by any VPN or proxy. 

We observe a smaller fraction of the ecosystem (16 clusters, 148 pages) than \cite{crawlphish} employs this cloaking technique, especially when it comes to triggering a notification pop-up to verify user interaction. This could be a result of Firefox, citing low engagement with the notifications, started requiring user interaction to trigger the popup\cite{mozillaRestrictingNotificationPermission2019} at the end of November 2019, when crawlphish's data collection ended. Chrome has since discussed modifying the notification API to make the request less disruptive to the user experience\cite {IntroducingQuieterPermission}. The lack of pop-up requests could also be explained by our \textbf{Finding-XX} regarding usage of Fetch and XMLHttpRequest or by the overwhelming amount of the pages (67\%) registering at least one HTMLElement event handler, which would be classified as a \textit{Click-through} by Crawlphish's taxonomy. We report a full breakdown of APIs related to the crawlphish categorization of client-side cloaking in Table~\ref{tab:crawlphish}.  
% Mouse APIs are cluster specific

\paperFinding{Mouse Detection API calls are specific to a small group of clusters}
While supported by most modern browsers, we see a very rare use of Mouse Detection APIs. Only 35 clusters employ mouse detection-related APIs. Two of these clusters\footnote{Split due to infrastructure insability causing crashes in early crawls} are from an open-source phishing kit, leveraging botguard, from GitHub, which was last updated in 2017\footnote{\url{https://github.com/ashanahw/Gmail_Phishing}}. We see these clusters deploy across 17 unique domains, starting from 2023-10-07 all the way to 2024-07-19. 



\paperFinding{The phishing ecosystem consists of clusters that utilize both cutting-edge, experimental browser APIs, and extremely deprecated APIs} We find 421 clusters (8270 pages) that utilize \textit{NavigatorUAData.getHighEntropyValues} for fingerprinting and \textit{Keyboard.lock} to restrict user input, APIs not fully supported by Firefox and Safari. We identified 10 clusters across 4,433 pages that used \textit{Scheduling.isInputPending}, however, upon closer inspection, these were not pages using a novel kit, but rather pages that used Google Sheets in order to construct their landing page. On the other hand, 25\% of the clusters spanning (47,001) pages use a deprecated API. 
While not experimental, WebAssembly is still a relatively modern web practice. We find a total of 199 clusters (5,107 pages) that use WebAssembly related APIs. Upon manual inspection of 33 unique WASM modules present on these pages, we identify bot-detection, in most cases, by using FriendlyCaptcha, as the most common use case for WebAssembly in phishing. 
\section{Discussion (1 page)}
\label{sec:discussion}
\input{figures/brand_vs_phishing.tex}
\subsection{Why clusters?}
As we have shown in the examples in this paper, phishing feeds can be a noisy data source for studying the overall ecosystem. From e-commerce pages to mass-spammed USPS and EZ-parking phishing pages, differentiating between a handful of pages of varying sizes becomes crucial for efficiency. This paper demonstrates that browser API usage can closely proxy the phishing kit (providing commonality for the page's origin) as best, and group via common client-side techniques as worst.

Furthermore, kit identification lets you infer server-side behavior about a particular page as long as a kit is identified and analyzed for one of the pages. As established by Oest\etal, Phishing kits thrive on including up-to-date IP blocklists. However, this blocklist is not always included in the client-side code. Being able to link pages to the same kit without any anti-evasion techniques like dynamic execution will allow better triaging of failed detections from phishing feed crawlers, something prior work established can be done by prior profiling\todocite{PriorProfiling}.

\subsection{What makes a kit identifiable?}
Sets of browser APIs used is not the most granual method to describe pages, however, without with some many degrees of freedom in choises, the most sophisicated the phishing kit becomes, the easier it is to spot by just the browser APIs it uses. In plain javascript, without browser APIs, a page can not reach out to a C2 serve, gather browser finterprints, dybamically generate or cloak page contents, or request browser pop-ups without calling out to a browser API. In the case of the pages clustered in Figure-\ref{fig:ms_defender}, the APIs \textit{Keyboard.lock}, \textit{HTMLDocument.onkeydown} for keyboard locking, \textit{Window.atob} for obfuscation, and a handful of fingerprint APIs and DOM APIs for dynamic content generation, set these pages apart from the other clusters. 

\paperFinding{Phishing pages vary wildly from the brand that they are mimicking}
We collect browser API traces from the login pages of Facebook, USPS, Meta, Microsoft, and IRS and compare them to their phishing counterparts. The average similarity of the APIs executed by the phishing page and the original page is 11\%, indicating that browser APIs do not relate to the target page. We found no pages where the original page's API set was a subset of the phishing page's API set, and in 5\% of the cases, the phishing page executed at least half of the APIs from the original page. We report per-brand findings in Table-~\ref{tab:phishing-metrics} and note that the least similar brand was USPS, which could be the result of USPS phishing pages being multi-stage pages requiring user interaction and targeting credit card information\todocite{\url{https://isc.sans.edu/diary/30078}}

This, however, does not indicate to use that browser API usage along is a good indicator of malicousness. All of the tehcniques described in Section-\ref{sec:methods} are common throughout the web, however, phishing pages are singular in their purpose, and their choise to engage in these techniques is what sets them apart from one another.

\subsection{Dynamic analysis combats evasions}
While dynamic analysis suffers from drawbacks we will discuss in Section-\ref{sec:limitations}, in javascript, it allows us to effectively sidesteps any sophisicated obfuscation techniques. Even something something as neuoused as an AES encrypted script will show up in VisisbleV8 as long as the bahavior is triggered. While not incorporated by our work, prior-work has shown forced execution \cite{fv8-sec24,crawlphish} to be an effective way of ensuring all behaviors are extracted by dynamic analysis.